####第一步：
项目中创建一个js文件（我通常给它取个名字为bus.js），引入vue，创建一个vue实例，导出这个实例，代码如下（一共就两行）：

```js
 import Vue from 'Vue'
 export default new Vue
```

####第二步：

在两个需要通信的两个组件中分别引入这个bus.js

```js
import Bus from '这里是你引入bus.js的路径' // Bus可自由更换喜欢的名字 
```

#### 第三步：

传递数据的组件里通过vue实例方法$emit发送事件名称和需要传递的数据。(发送数据组件)

```js
Bus.$emit('click',data) // 这个click是一个自定义的事件名称，data就是你要传递的数据。 
```

####第四步：

被传递数据的组件内通过vue实例方法$on监听到事件和接受到数据。（接收数据的组件）这里通常挂载监听在vue生命周期created和mounted当中的一个，具体使用场景需要具体的分析，这里不说这个。

```js
1 Bus.$on('click',target => {
2 　　console.log(target)　　//　注意：发送和监听的事件名称必须一致，target就是获取的数据，可以不写target。只要你喜欢叫什么都可以（当然了，这一定要符合形参变量的命名规范）
3 })
```

通过以上的四步其实就已经实现了最简单的eventbus的实际应用了。

但是到这儿后，一定要注意一个最容易忽视，又必然不能忘记的东西，那就是**清除事件总线eventBus**.

不手动清除，它是一直会存在的，这样的话，有个问题就是反复进入到接受数据的组件内操作获取数据，原本只执行一次的获取的操作将会有多次操作。如上我所举的例子，只是打印多次传过来的数据。但你想想，实际开发中是不会这么简单的打印这个数据到控制台，本来只会触发并只执行一次，现在变成了多次，这个问题就非常严重了，你们各种脑补具体的项目开发场景吧。

####第五步：

在vue生命周期beforeDestroy或者destroyed中用vue实例的$off方法清除eventBus

```js
 beforeDestroy(){
     bus.$off('click')
  }
```

总结一下，这里只是介绍如何使用eventBus来解决非父子组件通信，但是当项目较大较复杂时，并不适合。到那时，vuex才是vue给我们提供的最理想的方式。